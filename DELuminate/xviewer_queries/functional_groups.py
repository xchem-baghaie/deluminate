from copy import deepcopy
from typing import List, Dict
import os

import pandas as pd
from rdkit import Chem

from configs.inputs import FunctionalGroupConfig, ReactionConfig, ReactionBranchConfig
from transforms.rdkit_mols import (
    parallel_map_compute_mol_from_smiles,
    parallel_map_compute_smiles_from_mol,
)
from tools.substructure_searching import parallel_map_has_substructure_match


def generate_dict_of_functional_groups(
    filepath: str = "./DELuminate/xviewer_queries/Functional Groups.csv",
) -> Dict:
    """
    Constructs a dictionary of the form {fg_name: fg object}, to mimic the table of functional groups in X-Viewer.
    Currently, this pulls from a static file, which is generated by hand.
    """
    df = pd.read_csv(filepath).fillna("")
    fg_dict = {}
    for i in range(len(df)):
        fg_name = df["GROUP_NAME"][i]
        smarts = df["SMARTS_STRING"][i]
        example_smiles = df["EXAMPLE_SMILES"][i]
        compound_proposal_rule = df["COMPOUND_PROPOSAL_RULE"][i]
        new_bb_purchase_rule = df["NEW_BB_PURCHASE_RULE"][i]
        fg = FunctionalGroupConfig(
            fg_name,
            smarts,
            example_smiles,
            compound_proposal_rule,
            new_bb_purchase_rule,
        )
        fg_dict[fg_name] = fg
    return fg_dict


def query_functional_groups_by_first_reaction_in_reaction_branch(
    reaction_branch: ReactionBranchConfig,
    working_df: pd.DataFrame,
    bbs: List[Chem.rdchem.Mol],
    overwrite_existing_reaction_assignments: bool,
    forced_inclusion_bb_dict: Dict,
) -> pd.DataFrame:
    """
    Queries a table for any entries which match any of the functional groups in the desired_fg_list, but do not contain any functional groups in the undesired_fg_list for a given reaction.
    Duplicate XBBIDs are dropped, keeping the first entry.
    Currently, this pulls from a static file, containing an export of XBBs from X-Viewer, but the idea is that this would pull directly from the BB table in X-Viewer, and
    operate exactly as the currently existing functional group search operates.
    """
    df = working_df
    df["Include"] = ["Yes"] * len(df)
    df["Excluded By User (XBBID)"] = ["No"] * len(df)
    df["Excluded By User (FG)"] = ["No"] * len(df)
    df["Contains All Compatible FGs"] = ["No"] * len(df)
    rxn = reaction_branch.reaction_sequence[0]
    if overwrite_existing_reaction_assignments:
        df["Reaction Sequence ID"] = [reaction_branch.reaction_branch_idx] * len(df)
        for i in range(len(df)):
            for j in range(len(reaction_branch.reaction_sequence)):
                df.loc[i, ["Reaction " + str(j + 1)]] = (
                    reaction_branch.reaction_sequence[j].rxn_name
                )
    # desired_fg_list = rxn.allowed_fgs_reactant2 + rxn.manually_added_fgs_reactant2
    undesired_fg_list = (
        rxn.manually_excluded_fgs_reactant2
    )  # + rxn.forbidden_fgs_reactant2 #the commented out variable is excluded during monosynthon enumeration
    contains_all_compatible_fgs = ["No"] * len(df)  # init
    incompatible_fg_ls = [""] * len(df)  # init
    # Filter out any bbs which contain an undesired functional group
    if len(undesired_fg_list) > 0:
        for fg in undesired_fg_list:
            matches = parallel_map_has_substructure_match(bbs, fg.smarts)
            for i in range(len(df)):
                if matches[i]:
                    incompatible_fg_ls[i] = incompatible_fg_ls[i] + f"~ {fg.fg_name} ~"
    df["Excluded By User (FG)"] = incompatible_fg_ls

    # Desired functional group query
    # df_list = []
    if len(rxn.allowed_fgs_reactant2) > 0:
        allowed_fg_mask = [False] * len(bbs)  # init
        for fg in rxn.allowed_fgs_reactant2:
            # Must match at least one of the allowed FGs. If it does, then allowed_fg_mask[i] is set to True
            mask = parallel_map_has_substructure_match(bbs, fg.smarts)
            for i in range(len(mask)):
                if mask[i]:
                    allowed_fg_mask[i] = True
    else:
        allowed_fg_mask = [True] * len(bbs)
    desired_fg_masks = [allowed_fg_mask]
    desired_fg_master_mask = []
    for fg in rxn.manually_added_fgs_reactant2:
        # Add a mask for each of the manually added FGs
        desired_fg_masks.append(parallel_map_has_substructure_match(bbs, fg.smarts))
    for i in range(len(bbs)):
        # Check whether each BB matches all of the desired FG criteria (allowed and added)
        contains_all_required_fgs = all([mask[i] for mask in desired_fg_masks])
        if contains_all_required_fgs:
            contains_all_compatible_fgs[i] = "Yes"
        desired_fg_master_mask.append(contains_all_required_fgs)
    df["Contains All Compatible FGs"] = contains_all_compatible_fgs
    for i in range(len(df)):
        if (
            df["Contains All Compatible FGs"][i] != "Yes"
            or df["Excluded By User (FG)"][i] != ""
        ):
            df.loc[i, ["Include"]] = "No"
    df = df[desired_fg_master_mask]
    df = df.reset_index(drop=True)
    if forced_inclusion_bb_dict is not None:
        mask = []
        for i in range(len(df)):
            xbbid = str(df["XBBID"][i])
            mask.append(
                reaction_branch.reaction_branch_idx == forced_inclusion_bb_dict[xbbid]
            )
        df = df[mask]
        df = df.reset_index(drop=True)
    working_df_chunk = df.drop_duplicates(subset="XBBID", keep="first").reset_index(
        drop=True
    )
    #Reset the reaction names for reaction branches > 1 in the dataframe if we didn't actually use them
    for i in range(10):
        if i > len(reaction_branch.reaction_sequence) and f"Reaction {i}" in list(working_df_chunk.columns):
            working_df_chunk[f"Reaction {i}"] = [""] * len(working_df_chunk)
    return working_df_chunk


def query_df_by_reaction_compatibility(
    df: pd.DataFrame,
    rxn_list: List[ReactionConfig],
    out_dir: str = "/mnt/p/discovery chemistry/people/ryan/tech dev - cheminformatics/enumeration/compatible_bbs_by_reaction/",
) -> None:
    """
    For a series of reactions (`rxn_list`), filters a dataframe (`df`) for only SMILES which are compatible with a given reaction, and writes the filtered df out to `out_dir`.

    This may be used for virtual library enumeration.
    """

    os.makedirs(out_dir, exist_ok=True)

    ss = list(df["SMILES"])
    ms = parallel_map_compute_mol_from_smiles(ss)

    REACTIONS_TO_IGNORE = [
        "Blank (124 Oxadiazole Intermediate)",
        "Blank (134 Oxadiazole Intermediate)",
        "Blank (Alkene Primary Amine Oxidative Ring Expansion Intermediate)",
        "Blank (Boc On)",
        "Blank (Halide Reduction (Br or I))",
        "Blank (Halide Reduction (Cl Br or I))",
        "Blank (No Reaction)",
        "Blank (SNAr of Hydroxide)",
        "Blank (XLIB0083 Azide Intermediate)",
        "Blank (XLIB0112 Diketopiperazine Intermediate)",
        "Blank (Acylation of AcOSu)",
        "Reductive Amination",
        "Reductive Amination (Ketones and Aldehydes)",
        "Reverse Amidation",
        "SN2 (Amine BBs)",
        "SNAr (Amines)",
        "SNAr onto pyrimidine (2-Cl displacement) (Amine BBs)",
        "SNAr onto pyrimidine (4-Cl displacement) (Amine BBs)",
        "Ullman Coupling",
        "Urea Formation (Amines)",
        "XLIB0099 124-Oxadiazole Formation ClAcOH then SN2 (Amine BBs)",
        "XPL0012 Cyc B Reductive Amination (Replacing Amine Linker)",
        "XPL0070 Urea Formation",
        "XPL0132 Oxazole Formation",
        "Z_AZLIB0002 Aldol Condensation (Cyanoacetamide Only)",
        "Z_AZLIB0003B Null Reaction SNAr Halides",
        "Z_AZLIB0021-CycA-XBB024871",
        "Z_AZLIB0021-CycA-XBB040765",
    ]

    for rxn in rxn_list:
        if rxn.num_reactants > 1 and rxn.rxn_name not in REACTIONS_TO_IGNORE:
            print(rxn.rxn_name)
            df_copy = deepcopy(df)
            ms_copy = deepcopy(ms)

            master_mask = [False] * len(ms)  # init

            for allowed_fg in rxn.allowed_fgs_reactant2:
                print(f"Checking for presence of {allowed_fg.fg_name}")
                # Must match at least one of the allowed FGs. If it does, then master_mask[i] is set to True
                allowed_mask = parallel_map_has_substructure_match(
                    ms_copy, allowed_fg.smarts
                )
                for i in range(len(allowed_mask)):
                    if allowed_mask[i]:
                        master_mask[i] = True

            for forbidden_fg in rxn.forbidden_fgs_reactant2:
                print(f"Checking for absence of {forbidden_fg.fg_name}")
                # Must not match any of the forbidden FGs. If it does, then master_mask[i] is set to False
                forbidden_mask = parallel_map_has_substructure_match(
                    ms_copy, forbidden_fg.smarts
                )
                for i in range(len(forbidden_mask)):
                    if forbidden_mask[i]:
                        master_mask[i] = False

            df_out = df_copy[master_mask]
            df_out = df_out.reset_index(drop=True)
            df_out.to_csv(f"{out_dir}{rxn.rxn_name}.csv", index=False)

            df_xbbs = df_out[df_out["Set"] == "XBBs"]
            df_xbbs = df_xbbs.reset_index(drop=True)
            df_xbbs.to_csv(f"{out_dir}/XBBs_only/{rxn.rxn_name}.csv", index=False)

    return None


if __name__ == "__main__":
    from xviewer_queries.reactions import generate_dict_of_reactions

    df = pd.read_csv(
        "/mnt/p/discovery chemistry/people/ryan/tech dev - cheminformatics/enumeration/XC_And_Commercial_BBs.csv",
        low_memory=False,
    ).fillna("")
    rxn_list = list(generate_dict_of_reactions().values())
    query_df_by_reaction_compatibility(df, rxn_list)
